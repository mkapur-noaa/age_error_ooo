---
title: "Resampling age-err matrix"
output: html_notebook
---
```{r}
require(dplyr)
require(ggplot2)
require(reshape2)
getP_al <- function(theta, aa, sigma){
  pal = NA
  if(theta == 1){
    pal <- pnorm(theta, aa, sigma)
  } else if (theta > 1 & theta < n_c){
    pal <- pnorm(theta+1, aa, sigma) - pnorm(theta, aa, sigma)
  } else if (theta == n_c){
    pal <- 1-pnorm(theta, aa, sigma)
  }
  pal
  
}
```



From p 170 of the SS User Manual v `3.30.15`:
"Currently, the aging error matrix is multiplied by the expected distribution of proportions at
age, while the more correct order of operations would be to sample true ages, and then sample
the observed age including aging error (it is possible these are mathematically identical)."

Let's demonstrate whether that is true in a simple case, and whether there are edge cases where it is not true, and what impact if any this might have on derived quantities/model fits.


## Super simple 
ignoring any fisheries considerations, let's look at this from a math-stat standpoint.
The question really comes down to, is mutiplying an ageing-error matrix (basically a vector of probabilities) by the observed population the same as instead sampling the observed population with the same pars that made up the age err matrix?

```{r super simple setup}
# matehmatically
## random matrix %*% fixed matrix of probs is not the same as
## sampling random matrix with probs

nsamp <- 10
ntrial <- 1

true_freq <- exp(rnorm(nsamp)); true_freq <- true_freq/sum(true_freq)

age_err <- replicate(10, sapply(10, FUN = function(x){mat = exp(rnorm(x))
                                          return(mat/sum(mat))}))%>%
  unlist() %>% matrix(., nrow= nsamp, ncol = nsamp)
## take nsamp samples ntrials times, given underlying true pop 
## will return integer observations
exp_pop0 <- t(rmultinom(size = nsamp, n = ntrial, prob = true_freq))
exp_pop1 <- exp_pop0 %*% age_err
exp_freq <-c(exp_pop1/sum(exp_pop1)) 


for(a in 1:nsamp) {
  (t(rmultinom(size = exp_pop0[a], n = 1, prob = age_err[,a])),"\n")
}

plot(exp_freq~true_freq, ylim = c(0,1), xlim = c(0,1));abline(a = 0, b = 1, col = 'blue')
```


Here's the current SS approach:

The expected proportion of observed numbers-at-age must account for imprecision and bias in ageing due to otolith reads occurring at different labs and/or by different readers. The ageing error matrix converts true ages $a$ into expected ages $\widetilde{a}$, the expected age value at age $a$ and sex $\gamma$ at the midpoint of year $y$ (when samples are obtained). First, a distribution of expected ages (which may differ from true age) is defined as:
 
\begin{equation}
P_{\gamma,a,\tilde a}^f=
\begin{cases}
\Phi  (\theta_2 ,a, \sigma_{a,\gamma}^f ) & \tilde a = 1 \\
 \Phi  (\theta_{a+1} ,a, \sigma_{a,\gamma}^f )-\Phi  (\theta_2 ,a, \sigma_{a,\gamma}^f ) &  1 < \tilde a < A \\
1-\Phi  (\theta_A ,a, \sigma_{A,\gamma}^f ) &  \tilde a = A
\end{cases} 
\end{equation} 

where $P_{\gamma,a,\tilde a}^f$ 	is the probability of an animal of sex $\gamma$ and true  age $\tilde a$ to be observed as age $\widetilde{a}$ from data collected by fleet $f$ (i.e., the ageing error matrix); $\widetilde{a}$	is the estimated  age $a$ incremented to mid-year values by adding 0.5; $\Phi$ is the cumulative normal density function;
$\theta_a$	is the lower limit of age bin $a$; and
${\sigma_a^f}_\gamma$	is the fishery-, age- and sex-specific standard deviation of observed ages.

The expected catch-at-age for fishery or survey  $f$ in year $y$ (expressed as proportions) is calculated by multiplying the midyear numbers-at-age by the ageing error matrix and dividing by the total numbers-at-age vulnerable to fishery $f$:

\begin{equation}
\rho_{y,\gamma,a}^{f=fishery} = \frac{\sum_i \phi^{if} P_{\gamma,a,\tilde a}^f  s_{M_{y,\gamma,a}}^f  F_y^{2f}(1-\Omega_{M_{y,\gamma,a}})N_{M_{y,\gamma,a}}}{\sum_{i,a}\phi^{if} P_{\gamma,a,\tilde a}^f  s_{M_{y,\gamma,a}}^f  F_y^{2f}(1-\Omega_{M_{y,\gamma,a}})N_{M_{y,\gamma,a}}}

\end{equation} 

\begin{equation}
\rho_{y,\gamma,a}^{f=survey} = \frac{\sum_i \phi^{if} P_{\gamma,a,\tilde a}^f  s_{M_{y,\gamma,a}}^f  N_{M_{y,\gamma,a}}}{\sum_{i,a}\phi^{if} P_{\gamma,a,\tilde a}^f  s_{M_{y,\gamma,a}}^f N_{M_{y,\gamma,a}}}

\end{equation} 

This is more complicated than a simple example because it includes discards and subseasonality.
For a basic case, we can simply have the ageing error matrix, and selectivity-at-age, fishing mortality, and numbers at age.

```{r}
# n_c = 25
# naa <- rep(NA, n_c)
# naa[1] <- 100; for(a in 2:n_c)naa[a] <- ceiling(naa[a-1]*exp(-0.2))
# plot(naa, ylab = 'True N', xlab = 'Age')


## ageing error matrix
# sd_a <- c(0.001, seq(0.175,1.5, length.out = n_c-1))## vector of sds at age
# sd_a <- 2e-1*(1:n_c)

age_err_matrix ## P




# for(a_obs in 1:n_c){
#   for(a_tilde in 1:n_c){
#     age_err_matrix[a_obs,a_tilde] <- getP_al(theta = a_tilde, aa = a_obs, sigma =0.1)
#   }
# }
# 
# age_err = matrix(NA, ncol = n_c, nrow = n_c) 
# 
# for(aprime in 1:n_c){ ## loop over obs ages (rows)
#   # age_err[,1] <- c(1,rep(0, nrow(age_err)-1)) ## age zeros, known without error
#   age_err[aprime,1] <-  pnorm(aprime,age_bias[1],sd_a)
#   for(a in 2:n_c){ ## loop over true ages (columns)
#     if(a == n_c){
#       age_err[aprime,a] <- 1-pnorm(n_c,age_bias[a],sd_a)
#     }
#     ## read, "given that at true age a we expect a mean observation of age_bias[a] and sd_a[a],
#     ## what is the chance of observing a value between agebin aprime and aprime+1?
#     ## if bias were zero, this distribution would be centered (maximized) along the diagonal,
#     ## when aprime = a. since there is bias, we expect the vector (column) associated with
#     ## true age a to be a normal distribution centered elsewhere.
#     age_err[aprime,a] <-  pnorm(aprime+1,age_bias[a], sd_a)-pnorm(aprime,age_bias[a], sd_a)
#   } ## end age
# } ## end aprime
# # } #end fleets
# age_err <- as.matrix(age_err)
# plot(age_err[3,])
# rowSums(age_err)
# colSums(age_err)
```



## Thorson's multinomial example
This is code from Jim that  doesn't deal with F/selex etc explicitly.
Instead, the "true" population compositions are defined by defining a vector of lognormal proportions of length $a$, where $a$ is the number of bins in question
```{r code from JT}
## Annotated/Modified by M Kapur, Oct 2021
# Based on:
#  https://stats.stackexchange.com/questions/24705/can-i-use-glm-algorithms-to-do-a-multinomial-logistic-regression

# Developed from:
#  Conversations with Brandon Chasco, Dave Warton, Joanna Mills-Flemming

# Please do not re-use without discussions with me (Jim Thorson)
#  NOTE that I would be happy to collaborate on work along these lines


n_c = 25 ## number of age bins
n_s = 20 ## number of samples to take from each bin  (does up to this number)
n_r = 1000 ## number of times to repeat the experiment


## ageing error matrix (no bias)
sd_a <- rep(1e-4,n_c) 
age_err_matrix <- matrix(NA, nrow = n_c, ncol = n_c) ## rows are true age, cols are read age (a_tilde)
for(a_obs in 1:n_c){
  age_err_matrix[,a_obs] <- sapply(1:n_c, FUN = getP_al, aa = a_obs, sigma = sd_a[n_c])
}
for(a_obs in 1:n_c){
  age_err_matrix[,a_obs] <-   age_err_matrix[,a_obs] /colSums(age_err_matrix)[a_obs]
}
colSums(age_err_matrix)

ggplot(reshape2::melt(age_err_matrix),aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() + coord_equal() + 
  # coord_flip()+
  scale_y_reverse(expand = c(0,0)) +
  scale_x_continuous(expand = c(0,0), position ='top') +
  theme_minimal()+
  labs(x='Read Age', y = 'True Age')


Size = 1:n_s
Results_rcz = array(0, dim=c(n_r,n_c,3))

for( rI in 1:n_r ){
  prop_c = exp(rnorm(n_c)) ## randomly generate a vector of lognormal proportions for this experiment; length equal to number of bins 
  prop_c = prop_c / sum(prop_c) ## rescale to get "true" population comp in bin (sums to 1)
  
  # sample from multinomial
  ## the prob of observing a given bin is given by prop_c
  
  ## 20 times take a multinom sample using prop_c as the probs, return vector of length prop_c"
  ## each time the number of individuals to measure varies by Size
  ## "20 times perform a multinomial 
  Y_sc = t(sapply( Size, FUN=rmultinom, n=1, prob=prop_c))
  

  # Convert to data frame
  ## These are the sampled expected ages a-tilde
  Y_iz = data.frame(
    y = as.vector(Y_sc), ## number observed
    c = as.vector(col(Y_sc)), ## bin (e.g. age)
    s = as.vector(row(Y_sc)) ## sample id (akin to "haul", always max n_s)
  )
  
  ## typical comps setup
  expected_1 <- tidyr::pivot_wider(Y_iz, values_from = y, names_from = c, id_cols = s) %>% 
    select(-s) %>%
    as.matrix()
  ## Approach 1 (SS approach)
  ## Multiply the expected ages, given above by Y_iz, by the ageing error matrix
  
  approach_1 <- expected_1 #%*% age_err_matrix 
  
  ## normalize
  # for(s_obs in 1:n_s){
  #   approach_1[s_obs,] <-   approach_1[s_obs,] /rowSums(approach_1)[s_obs]
  # }

  
  ## Approach 2 ('correct' approach')
  ## Resample Y_iz using values from ageing error matrix (multinomial)
  ## the prob of observing a given bin is given by prop_c
  # approach_2<- matrix(NA, nrow= n_s, ncol = n_c)
  approach_2_temp <- matrix(NA, nrow = n_c, ncol = n_c) ## square matrix for summations
  ## for each age bin, read the number of otoliths that are truly in that age
  ## assign them to ages via the age-err matrix
  ## then sum these up and normalize to get a single compositional vector for this experiment
  ## repeat for each experimeng
  n_otoliths <- colSums(expected_1)
    
  # for(i_s in 1:n_s){
     for(a_obs in 1:n_c){
      approach_2_temp[a_obs,] <-  t(rmultinom(size  = n_otoliths[a_obs], 
                                             n = 1,
                                             prob = age_err_matrix[,a_obs])) %>% as.matrix()
      
     } ## end ages
    # approach_2_sums<- colSums(approach_2_temp) ## sum (putative vector)
    approach_2 <-   colSums(approach_2_temp)/sum(approach_2_temp) ## normalize
  # } ## end experiments


 
  # Fit Poisson-GLM
  ## independent effects of haul (or sample, s) and bin (c); based on your observations
  ## can be used to predict more obs...
  ## 0+ means intercept is suppressed
  # G = glm( y ~ 0 + factor(c) + factor(s), data=Y_iz, family=poisson() )
  
  # Extract effects (with data, try to estimate true pop comp (prop_c))
  # there is a coefficient for each unique bin (c, 10) and each unique haul s minus 1 
  # prophat_c = summary(G)$coef[paste0("factor(c)",1:n_c),'Estimate'] ## bin effects only
  # prophat_c = exp(prophat_c) / sum(exp(prophat_c)) ## rescale
  
  # Record results'
  Results_rcz[rI,,1] = prop_c ## true observed props
  Results_rcz[rI,,2] = colSums(approach_1)/sum(approach_1) ## current method, normalized
  Results_rcz[rI,,3] = approach_2 ## alt method, normalized
  # Results_rcz[rI,,1] = prop_c ## true observed props
  # Results_rcz[rI,,2] = prophat_c ## or estimated props
}

mn = Results_rcz; rm(Results_rcz)

## shows that we get some error around observations
plot( x=mn[,,1], y=mn[,,2], log="",
      xlab = 'True',ylab = 'Simulated')
abline(a=0, b=1, col="blue")

## plot it in a clearer way
# Results_rcz has nrow = experiments or hauls, ncol = age bins, arrays = 1true, 2obscurr, 3obsalt

plotme <-  data.frame(mn[,,1]) %>%
  mutate(haulid = 1:1000) %>%
  melt(id = 'haulid') %>%
  mutate(src = 'obs', 
         age = as.numeric(substr(variable,2,2))) %>%
  rbind( data.frame(mn[,,2]) %>%
           mutate(haulid = 1:1000) %>%
           melt(id = 'haulid') %>%
           mutate(src = 'pred', 
                  age = as.numeric(substr(variable,2,2)))) %>%
  select(-variable) %>%
  filter(haulid < 21) ## for plotting

ggplot(NULL, aes(x = age, y = value, fill = src, color = src)) +
  geom_histogram(data = subset(plotme, src == 'obs', fill = 'obs'),stat = 'identity' ) +
  geom_line(data = subset(plotme, src == 'pred', color = 'pred'), lwd = 1.1) +
  scale_fill_manual(values = c('grey55',NA), labels = c('obs','simulated'))+
  scale_color_manual(values = c(NA, 'blue'), labels = c('obs','simulated'))+
  labs(x = 'age or length', y = 'freq', fill = '',
       color='', title = 'Multinomial Simulator, 20 hauls')+
  theme_minimal()+
  facet_wrap(~haulid)
```

